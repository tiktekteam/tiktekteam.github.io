<!DOCTYPE html>
<html
  lang="he"
  dir="rtl"
>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta
      http-equiv="Pragma"
      content="no-cache"
    />
    <meta
      http-equiv="Expires"
      content="0"
    />
    <title>פרבולה פוגשת ישרים שונים</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Cache busting script -->
    <script>
      // Clear browser cache for this page
      if ('caches' in window) {
        caches.keys().then(function (names) {
          names.forEach(function (name) {
            console.log('Clearing cache:', name);
            caches.delete(name);
          });
        });
      }

      // Add version timestamp to prevent JS caching
      const scriptTimestamp = new Date().getTime();
      const allScripts = document.querySelectorAll('script[src]');
      allScripts.forEach((script) => {
        if (!script.src.includes('?')) {
          script.src = script.src + '?v=' + scriptTimestamp;
        }
      });
    </script>
    <style>
      body {
        font-family: 'Arial', sans-serif;
        font-size: 110%; /* Increase base font size by 10% */
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
        background-color: #f4f4f9;
      }
      h1,
      h2 {
        color: #333;
        font-size: 95%; /* Reduced heading font size */
        margin: 5px 0; /* Reduced margin */
        line-height: 1.1; /* Tighter line height */
        padding: 5px;
      }
      .controls {
        margin-bottom: 10px;
        padding: 0px 10px;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        text-align: right;
      }
      .controls p {
        margin-bottom: 5px;
        margin-right: 0;
        padding-right: 0;
        font-size: 90%; /* Reduced font size */
        margin-top: 5px;
      }
      .controls label {
        display: block;
        margin-bottom: 2px;
        margin-left: 0;
        cursor: pointer;
        padding: 0;
      }
      .controls label:last-child {
        padding-bottom: 10px;
      }
      .controls input[type='radio'] {
        margin-left: 2px;
        margin-right: 1px;
      }
      #chartContainer {
        font-size: large;
        width: 80%;
        max-width: 700px;
        margin-bottom: 20px;
        background-color: #fff;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        padding-top: 1px !important;
      }
      canvas {
        display: block;
        width: 100%;
        height: auto;
      }
      button {
        padding: 10px 20px;
        font-size: 16px;
        color: #fff;
        background-color: #007bff;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
        margin-top: 10px;
      }
      button:hover {
        background-color: #0056b3;
      }
      #explanationBox {
        width: 80%;
        max-width: 700px;
        margin-top: 20px;
        padding: 15px;
        background-color: #e9ecef;
        border: 1px solid #ced4da;
        border-radius: 8px;
        text-align: right;
        line-height: 1.6;
        font-size: 82.5%; /* Reduced by 25% from 110% */
      }
      #screenshotContainer {
        margin-top: 20px;
        text-align: center;
        width: 80%;
        max-width: 700px;
        font-size: 110%; /* Increase screenshot container text by 10% */
      }
      #screenshotContainer img {
        max-width: 100%;
        border: 1px solid #ccc;
        margin-top: 10px;
      }
      #screenshotContainer a {
        display: block;
        margin-top: 10px;
        color: #007bff;
        text-decoration: none;
      }
      #screenshotContainer a:hover {
        text-decoration: underline;
      }

      /* Header container for tighter spacing */
      .header-container {
        text-align: center;
        margin-bottom: 5px;
        line-height: 1;
      }

      /* Media queries for responsive design */
      @media (max-width: 768px) {
        body {
          padding: 5px;
        }

        h1,
        h2 {
          font-size: 85%;
          text-align: center;
          margin: 2px 0;
        }

        #chartContainer,
        #explanationBox,
        #screenshotContainer {
          width: 95%;
          padding: 5px;
        }

        #chartContainer {
          margin-top: 5px;
          margin-bottom: 10px;
        }

        .controls {
          width: 95%;
          padding: 5px;
          margin-bottom: 10px;
        }

        .controls p {
          font-size: 85%;
          margin: 3px 0;
        }

        /* Stack grid columns vertically on mobile */
        .controls .grid-container {
          display: flex !important;
          flex-direction: column-reverse !important;
        }

        .controls label {
          margin-bottom: 8px;
          font-size: 90%;
        }

        button {
          width: 95%;
          max-width: 300px;
        }

        /* Fix chart scaling for mobile */
        canvas {
          height: auto !important;
          width: 100% !important;
        }

        /* Improve canvas sizing and proportions */
        #myChart {
          aspect-ratio: 1.3 / 1; /* Taller chart */
          height: 300px !important; /* Increased height */
        }

        /* Override Chart.js default styles for mobile */
        #chartContainer .chartjs-size-monitor {
          height: 300px !important;
        }

        /* Reduce legend margin and spacing */
        .chartjs-legend {
          margin-top: 0 !important;
          margin-bottom: 0 !important;
          padding: 2px !important;
        }

        #explanationBox {
          font-size: 82.5%;
          line-height: 1.4;
        }

        #explanationBox h3 {
          font-size: 90%;
          margin-top: 5px;
          margin-bottom: 5px;
        }

        #explanationBox p {
          margin-top: 3px;
          margin-bottom: 3px;
        }
      }

      /* Additional style fixes for RTL content */
      [dir='rtl'] .chartjs-tooltip {
        direction: rtl;
        text-align: right;
      }

      /* Make sure radio buttons are aligned properly */
      input[type='radio'] {
        vertical-align: middle;
      }

      /* Make the legend more compact */
      .chartjs-legend ul {
        margin: 0 !important;
        padding: 0 !important;
      }
    </style>
  </head>
  <body>
    <h1>פתרון גרפי למשוואות ריבועיות</h1>
    <h2>הפונקציה: y = x² - 5x</h2>

    <div class="controls">
      <p>בחר את המשוואה לפתרון גרפי:</p>
      <div
        class="grid-container"
        style="
          display: grid;
          grid-template-columns: 1fr 1fr 1fr;
          grid-gap: 0px;
          column-gap: 0;
          direction: rtl;
          margin: 0;
          padding: 0;
        "
      >
        <!-- עמודה שמאלית -->
        <div style="padding: 0; margin: 0">
          <label style="display: block; margin-bottom: 10px">
            <input
              type="radio"
              name="equation"
              value="5"
            />
            5) x² - 5x = x (קו y=x)
          </label>
          <label style="display: block">
            <input
              type="radio"
              name="equation"
              value="6"
            />
            6) x² - 6x = 0 (קו y=x)
          </label>
        </div>

        <!-- עמודה אמצעית -->
        <div style="padding: 0; margin: 0">
          <label style="display: block; margin-bottom: 10px">
            <input
              type="radio"
              name="equation"
              value="3"
            />
            3) x² - 5x = 6 (קו y=6)
          </label>
          <label style="display: block">
            <input
              type="radio"
              name="equation"
              value="4"
            />
            4) x² - 5x = -2 (קו y=-2)
          </label>
        </div>

        <!-- עמודה ימנית -->
        <div style="padding: 0; margin: 0">
          <label style="display: block; margin-bottom: 10px">
            <input
              type="radio"
              name="equation"
              value="1"
              checked
            />
            1) x² - 5x = 3 (קו y=3)
          </label>
          <label style="display: block">
            <input
              type="radio"
              name="equation"
              value="2"
            />
            2) x² - 5x = x + 4 (קו y=x+4)
          </label>
        </div>
      </div>
    </div>

    <div id="chartContainer">
      <canvas id="myChart"></canvas>
    </div>

    <div id="explanationBox">
      <!-- Explanation will be loaded here -->
    </div>

    <button id="generateScreenshotBtn">הראה פתרון מלא</button>

    <div id="screenshotContainer"></div>

    <script>
      const ctx = document.getElementById('myChart').getContext('2d');
      const explanationBox = document.getElementById('explanationBox');
      let myChart;
      let currentIntersectionPoints = []; // Store intersection points

      // Ensure responsive resizing
      function resizeChart() {
        if (myChart) {
          myChart.resize();
        }
      }

      // Add window resize listener
      window.addEventListener('resize', resizeChart);

      const mainFunction = (x) => x * x - 5 * x;

      // Helper function to solve quadratic equation ax^2 + bx + c = 0
      function solveQuadratic(a, b, c) {
        const delta = b * b - 4 * a * c;
        if (delta < 0) {
          return []; // No real solutions
        } else if (delta === 0) {
          const x = -b / (2 * a);
          return [x];
        } else {
          const x1 = (-b + Math.sqrt(delta)) / (2 * a);
          const x2 = (-b - Math.sqrt(delta)) / (2 * a);
          return [x1, x2];
        }
      }

      // Helper function to format numbers with 2 decimals only if needed
      function formatNumber(number) {
        // בדיקה אם המספר הוא שלם (או קרוב מאוד)
        if (Math.abs(Math.round(number) - number) < 0.0001) {
          return Math.round(number); // החזרת מספר שלם
        }
        // החזרת מספר עשרוני עם עד 2 ספרות אחרי הנקודה
        return parseFloat(number.toFixed(2));
      }

      // Format for display as text with minus sign in correct place for RTL
      function formatNumberForDisplay(number) {
        const formattedValue = formatNumber(number);
        if (formattedValue < 0) {
          // שימוש במינוס כאשר מספר שלילי מוצג בעברית
          return '-' + Math.abs(formattedValue);
        }
        return formattedValue;
      }

      // Function to get the line function and quadratic coefficients for intersection
      function getEquationDetails(equationValue) {
        let lineFunc;
        let a = 1,
          b = -5,
          c = 0; // Coefficients for x^2 - 5x - g(x) = 0

        switch (equationValue) {
          case '1': // x^2 - 5x = 3  => x^2 - 5x - 3 = 0
            lineFunc = (x) => 3;
            c = -3;
            break;
          case '2': // x^2 - 5x = x + 4 => x^2 - 6x - 4 = 0
            lineFunc = (x) => x + 4;
            b = -6;
            c = -4;
            break;
          case '3': // x^2 - 5x = 6 => x^2 - 5x - 6 = 0
            lineFunc = (x) => 6;
            c = -6;
            break;
          case '4': // x^2 - 5x = -2 => x^2 - 5x + 2 = 0
            lineFunc = (x) => -2;
            c = 2;
            break;
          case '5': // x^2 - 5x = x => x^2 - 6x = 0
            lineFunc = (x) => x;
            b = -6;
            c = 0;
            break;
          case '6': // x^2 - 6x = 0 => x^2 - 5x = x
            lineFunc = (x) => x;
            b = -6; // from x^2 - 6x = 0
            c = 0;
            break;
          default:
            lineFunc = (x) => NaN; // Should not happen
        }
        return { lineFunc, a, b, c };
      }

      // Calculate intersection points
      function calculateIntersections(equationValue) {
        const { lineFunc, a, b, c } = getEquationDetails(equationValue);
        const xSolutions = solveQuadratic(a, b, c);
        const points = xSolutions.map((x) => ({
          x: x,
          y: lineFunc(x), // Calculate y using the line function
        }));
        return points;
      }

      const lineFunctions = {
        1: getEquationDetails('1').lineFunc,
        2: getEquationDetails('2').lineFunc,
        3: getEquationDetails('3').lineFunc,
        4: getEquationDetails('4').lineFunc,
        5: getEquationDetails('5').lineFunc,
        6: getEquationDetails('6').lineFunc,
      };

      // We'll use a different approach for Chart.js - using data points directly
      // instead of being constrained by labels array
      function generatePoints(func, xMin, xMax, step) {
        const points = [];
        for (let x = xMin; x <= xMax; x += step) {
          points.push({
            x: x, // Use x directly as coordinate, not as label index
            y: func(x),
          });
        }
        return points;
      }

      function updateChart(selectedEquation) {
        const selectedLineFunc = lineFunctions[selectedEquation];

        // Calculate intersections for the selected equation
        currentIntersectionPoints = calculateIntersections(selectedEquation);

        // Dynamically calculate axis ranges with generous padding
        let yMin = Infinity,
          yMax = -Infinity;
        let xMin = Infinity,
          xMax = -Infinity;

        // Generate data points with a VERY wide range to ensure full curve visibility
        const xDataMin = -3; // Reduced data range
        const xDataMax = 8;

        // Generate data points for both functions
        const mainDataPoints = generatePoints(
          mainFunction,
          xDataMin,
          xDataMax,
          0.25
        );
        const lineDataPoints = generatePoints(
          selectedLineFunc,
          xDataMin,
          xDataMax,
          0.25
        );

        // Calculate min/max based on ALL data points
        mainDataPoints.forEach((point) => {
          if (point.y < yMin) yMin = point.y;
          if (point.y > yMax) yMax = point.y;
          if (point.x < xMin) xMin = point.x;
          if (point.x > xMax) xMax = point.x;
        });

        lineDataPoints.forEach((point) => {
          if (!isNaN(point.y)) {
            if (point.y < yMin) yMin = point.y;
            if (point.y > yMax) yMax = point.y;
            if (point.x < xMin) xMin = point.x;
            if (point.x > xMax) xMax = point.x;
          }
        });

        // Consider intersection points
        currentIntersectionPoints.forEach((p) => {
          if (p.y < yMin) yMin = p.y;
          if (p.y > yMax) yMax = p.y;
          if (p.x < xMin) xMin = p.x;
          if (p.x > xMax) xMax = p.x;
        });

        // Ensure minimum is not higher than the parabola's vertex (at x=2.5, y=-6.25)
        if (yMin > -6.25) yMin = -6.25;

        // Add VERY generous padding (50% of range)
        const yRange = yMax - yMin;
        const xRange = xMax - xMin;

        const yPadding = Math.max(yRange * 0.3, 3); // Reduced: 30% padding or 3 units
        const xPadding = Math.max(xRange * 0.2, 1); // Reduced: 20% padding or 1 unit

        // Set final ranges
        const finalYMin = Math.floor(yMin - yPadding);
        const finalYMax = Math.ceil(yMax + yPadding);
        const finalXMin = Math.floor(xMin - xPadding);
        const finalXMax = Math.ceil(xMax + xPadding);

        // Default axis range
        let minYViewRange = [-6, 13];
        let minXViewRange = [-1, 5];

        // Use the wider of calculated vs minimum ranges
        const displayYMin = Math.min(finalYMin, minYViewRange[0]);
        const displayYMax = Math.max(finalYMax, minYViewRange[1]);
        const displayXMin = Math.min(finalXMin, minXViewRange[0]);
        const displayXMax = Math.max(finalXMax, minXViewRange[1]);

        // Apply additional trimming to the final display ranges
        const trimmedXMin = Math.max(displayXMin + 2, -20); // Trim 2 units from left, but keep reasonable
        const trimmedXMax = Math.min(displayXMax - 2, 20); // Trim 2 units from right, but keep reasonable
        const finalDisplayXMin = trimmedXMin;
        const finalDisplayXMax = trimmedXMax;

        const datasets = [
          {
            label: 'y = x² - 5x',
            data: mainDataPoints,
            borderColor: 'rgb(0, 90, 200)',
            backgroundColor: 'rgb(0, 90, 200)', // כחול כהה יותר לפרבולה
            tension: 0.1,
            fill: false,
            pointRadius: 0, // Hide individual points for the main curve
            showLine: true, // IMPORTANT: Show connected line for scatter chart
            borderWidth: 3, // Make the line thicker for better visibility on mobile
          },
          {
            label: `קו עזר: ${getLineEquationString(selectedEquation)}`,
            data: lineDataPoints,
            borderColor: 'rgb(0, 160, 0)',
            backgroundColor: 'rgb(0, 160, 0)', // ירוק כהה יותר לקו העזר
            fill: false,
            borderDash: [5, 5], // Dashed line
            pointRadius: 0, // Hide individual points for the auxiliary line
            showLine: true, // IMPORTANT: Show connected line for scatter chart
            borderWidth: 3, // Make the line thicker for better visibility on mobile
          },
          {
            label: 'נקודות חיתוך',
            data: currentIntersectionPoints, // Use calculated points
            borderColor: 'rgb(200, 0, 0)', // אדום כהה יותר
            backgroundColor: 'rgb(200, 0, 0)', // אדום כהה יותר
            pointRadius: 8, // Make points even larger for better visibility on mobile
            pointHoverRadius: 10,
            showLine: false, // Don't connect the points with a line
            type: 'scatter', // Use scatter type for distinct points
          },
        ];

        if (myChart) {
          // Update existing chart
          myChart.data.datasets = datasets;
          myChart.options.scales.x.min = finalDisplayXMin;
          myChart.options.scales.x.max = finalDisplayXMax;
          myChart.options.scales.y.min = displayYMin;
          myChart.options.scales.y.max = displayYMax;
          // עדכון קפיצות בציר Y
          myChart.options.scales.y.ticks.stepSize = 5;
          myChart.options.scales.y.ticks.autoSkip = false;
          myChart.options.scales.y.ticks.major.enabled = true;
          // דאג שטווח ציר Y יהיה כפולה של 5
          if (myChart.options.scales.y.max % 5 !== 0) {
            myChart.options.scales.y.max =
              Math.ceil(myChart.options.scales.y.max / 5) * 5;
          }
          if (myChart.options.scales.y.min % 5 !== 0) {
            myChart.options.scales.y.min =
              Math.floor(myChart.options.scales.y.min / 5) * 5;
          }
          myChart.update('none'); // Update without animation for immediate effect
        } else {
          // Create new chart
          myChart = new Chart(ctx, {
            type: 'scatter', // Use scatter type to allow x,y coordinates directly
            data: {
              datasets: datasets,
            },
            options: {
              parsing: false, // Disable parsing for better performance with large datasets
              responsive: true,
              maintainAspectRatio: true,
              font: {
                size: 16 /* Increased font size for chart text */,
              },
              elements: {
                line: {
                  tension: 0.2, // Add some curve to the lines for smoother appearance
                },
              },
              animation: false, // Keep animations disabled
              scales: {
                x: {
                  title: {
                    display: false /* Hide x-axis label */,
                    text: 'x',
                    font: {
                      size: 10 /* More readable size */,
                      weight: 'bold',
                    },
                  },
                  // התאם את טווח ציר X
                  min: Math.min(-1, finalDisplayXMin),
                  max: Math.max(5, finalDisplayXMax),
                  type: 'linear', // Use linear scale for numerical x values
                  position: 'bottom',
                  display: true,
                  grid: {
                    offset: false, // Ensure grid lines pass through axes
                    color: function (context) {
                      // Make the zero line (y-axis) darker
                      if (context.tick.value === 0) {
                        return 'rgba(0, 0, 0, 1)';
                      }
                      return 'rgba(0, 0, 0, 0.1)';
                    },
                    lineWidth: (context) => (context.tick.value === 0 ? 2 : 1),
                  },
                  border: {
                    display: true,
                    width: 2,
                  },
                  grace: 0, // No padding around the data range
                  ticks: {
                    // פורמט מיוחד למינוסים בציר
                    callback: function (value, index, values) {
                      // Simple and reliable formatting for negative numbers
                      if (value === 0) return '0';
                      // For negative values, use a non-RTL approach
                      if (value < 0) {
                        const absValue = Math.abs(value);
                        const formatted = Number.isInteger(absValue)
                          ? absValue.toString()
                          : absValue.toFixed(1);
                        // Use a narrow no-break space (U+202D) to prevent RTL reordering
                        return '\u202D-' + formatted;
                      }
                      return Number.isInteger(value)
                        ? value.toString()
                        : value.toFixed(1);
                    },
                    font: {
                      family: 'Arial',
                      size: 10 /* More readable size */,
                      weight: 'bold',
                    },
                    mirror: false,
                    color: 'rgba(0, 0, 0, 1)',
                    padding: 8,
                  },
                },
                y: {
                  title: {
                    display: false /* Hide y-axis label */,
                    text: 'y',
                    font: {
                      size: 10 /* More readable size */,
                      weight: 'bold',
                    },
                  },
                  // התאם את טווח ציר Y לכפולות של 5
                  min: Math.floor(displayYMin / 5) * 5,
                  max: Math.ceil(displayYMax / 5) * 5,
                  display: true,
                  grid: {
                    offset: false, // Ensure grid lines pass through axes
                    color: function (context) {
                      // Make the zero line (x-axis) darker
                      if (context.tick.value === 0) {
                        return 'rgba(0, 0, 0, 1)';
                      }
                      return 'rgba(0, 0, 0, 0.1)';
                    },
                    lineWidth: (context) => (context.tick.value === 0 ? 2 : 1),
                  },
                  border: {
                    display: true,
                    width: 2,
                  },
                  grace: 0, // No padding around the data range
                  position: 'left', // Use standard position
                  beginAtZero: false, // Don't force zero to be included
                  axis: 'x', // Make y-axis cross the x-axis
                  crossAlign: 'center', // Align at center of x-axis
                  ticks: {
                    // פורמט מיוחד למינוסים בציר
                    callback: function (value, index, values) {
                      // Simple and reliable formatting for negative numbers
                      if (value === 0) return '0';
                      // For negative values, use a non-RTL approach
                      if (value < 0) {
                        const absValue = Math.abs(value);
                        const formatted = Number.isInteger(absValue)
                          ? absValue.toString()
                          : absValue.toFixed(1);
                        // Use a narrow no-break space (U+202D) to prevent RTL reordering
                        return '\u202D-' + formatted;
                      }
                      return Number.isInteger(value)
                        ? value.toString()
                        : value.toFixed(1);
                    },
                    // Ensure zero is included
                    major: {
                      enabled: true,
                    },
                    // קביעת קפיצות של 5 יחידות בציר Y
                    stepSize: 5,
                    autoSkip: false,
                    color: 'rgba(0, 0, 0, 1)',
                    padding: 8,
                    font: {
                      family: 'Arial',
                      size: 10 /* More readable size */,
                      weight: 'bold',
                    },
                  },
                },
              },
              plugins: {
                title: {
                  display: false /* Hide the title to save space */,
                  text: 'גרף הפונקציה והקו הישר לפתרון המשוואה',
                  font: {
                    size: 8 /* Reduced by half */,
                    weight: 'bold',
                  },
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                  bodyFont: {
                    size: 16,
                  },
                  titleFont: {
                    size: 16,
                  },
                  callbacks: {
                    // Customize tooltip for intersection points
                    label: function (context) {
                      if (context.dataset.label === 'נקודות חיתוך') {
                        const point = context.raw;
                        const xStr = formatNumberForDisplay(point.x);
                        const yStr = formatNumberForDisplay(point.y);
                        return `חיתוך: (${xStr}, ${yStr})`;
                      }
                      let label = context.dataset.label || '';
                      if (label) {
                        label += ': ';
                      }
                      if (context.parsed.y !== null) {
                        label += `y = ${formatNumberForDisplay(
                          context.parsed.y
                        )}`;
                      }
                      return label;
                    },
                  },
                },
                legend: {
                  labels: {
                    font: {
                      size: 9 /* More readable size */,
                    },
                  },
                  position: 'top',
                  align: 'center',
                  labels: {
                    boxWidth: 15,
                    padding: 5,
                    font: {
                      size: 9 /* More readable size */,
                      weight: 'bold',
                    },
                  },
                },
                cartesianAxes: {
                  enabled: true,
                },
              },
              interaction: {
                intersect: false,
                mode: 'index',
              },
            },
          });
        }
        // Update the explanation text after updating the chart
        updateExplanation(selectedEquation, currentIntersectionPoints);
      }

      // Function to generate explanation text
      function updateExplanation(equationValue, intersectionPoints) {
        let explanationHTML = `<h3>הסבר לפתרון המשוואה ${equationValue}</h3>`;

        // הסבר קצר למה נבחר הישר הספציפי + פתרון אלגברי
        switch (equationValue) {
          case '1':
            explanationHTML += `<p>כאשר אנו פותרים את המשוואה x² - 5x = 3, אנחנו בעצם מחפשים את ערכי x שבהם x² - 5x שווה ל-3.</p>

             <p>לכן, נקודות החיתוך בין הפרבולה y = x² - 5x לבין הישר y = 3 נותנות לנו את הפתרון.</p>

             <p><strong>פתרון אלגברי:</strong></p>
             <div dir="ltr" style="text-align: left;">
             x² - 5x = 3<br>
             x² - 5x - 3 = 0<br>
             x = ${
               Math.abs(
                 intersectionPoints[0]?.x - Math.round(intersectionPoints[0]?.x)
               ) < 0.0001
                 ? Math.round(Math.abs(intersectionPoints[0]?.x))
                 : Math.abs(intersectionPoints[0]?.x).toFixed(2)
             } או x = -${
              Math.abs(
                intersectionPoints[1]?.x - Math.round(intersectionPoints[1]?.x)
              ) < 0.0001
                ? Math.round(Math.abs(intersectionPoints[1]?.x))
                : Math.abs(intersectionPoints[1]?.x).toFixed(2)
            }
             </div>`;
            break;
          case '2':
            explanationHTML += `<p>כאשר אנו פותרים את המשוואה x² - 5x = x + 4, אנחנו מחפשים את ערכי x שבהם x² - 5x שווה ל-x + 4.</p>

             <p>לכן, נקודות החיתוך בין הפרבולה y = x² - 5x לבין הישר y = x + 4 נותנות לנו את הפתרון.</p>

             <p><strong>פתרון אלגברי:</strong></p>
             <div dir="ltr" style="text-align: left;">
             x² - 5x = x + 4<br>
             x² - 5x - x - 4 = 0<br>
             x² - 6x - 4 = 0<br>
             x = ${intersectionPoints[0]?.x.toFixed(
               2
             )} או x = ${intersectionPoints[1]?.x.toFixed(2)}
             </div>`;
            break;
          case '3':
            explanationHTML += `<p>כאשר אנו פותרים את המשוואה x² - 5x = 6, אנחנו מחפשים את ערכי x שבהם x² - 5x שווה ל-6.</p>

             <p>לכן, נקודות החיתוך בין הפרבולה y = x² - 5x לבין הישר y = 6 נותנות לנו את הפתרון.</p>

             <p><strong>פתרון אלגברי:</strong></p>
             <div dir="ltr" style="text-align: left;">
             x² - 5x = 6<br>
             x² - 5x - 6 = 0<br>
             x = ${intersectionPoints[0]?.x.toFixed(
               2
             )} או x = ${intersectionPoints[1]?.x.toFixed(2)}
             </div>`;
            break;
          case '4':
            explanationHTML += `<p>כאשר אנו פותרים את המשוואה x² - 5x = -2, אנחנו מחפשים את ערכי x שבהם x² - 5x שווה ל--2.</p>

             <p>לכן, נקודות החיתוך בין הפרבולה y = x² - 5x לבין הישר y = -2 נותנות לנו את הפתרון.</p>

             <p><strong>פתרון אלגברי:</strong></p>
             <div dir="ltr" style="text-align: left;">
             x² - 5x = -2<br>
             x² - 5x + 2 = 0<br>
             x = ${intersectionPoints[0]?.x.toFixed(
               2
             )} או x = ${intersectionPoints[1]?.x.toFixed(2)}
             </div>`;
            break;
          case '5':
            explanationHTML += `<p>כאשר אנו פותרים את המשוואה x² - 5x = x, אנחנו מחפשים את ערכי x שבהם x² - 5x שווה ל-x.</p>

             <p>לכן, נקודות החיתוך בין הפרבולה y = x² - 5x לבין הישר y = x נותנות לנו את הפתרון.</p>

             <p><strong>פתרון אלגברי:</strong></p>
             <div dir="ltr" style="text-align: left;">
             x² - 5x = x<br>
             x² - 5x - x = 0<br>
             x² - 6x = 0<br>
             x(x - 6) = 0<br>
             x = 0 או x = 6
             </div>`;
            break;
          case '6':
            explanationHTML += `<p>כאשר אנו פותרים את המשוואה x² - 6x = 0, אנחנו מחפשים את ערכי x שבהם x² - 5x שווה ל-x.</p>

             <p>לכן, נקודות החיתוך בין הפרבולה y = x² - 5x לבין הישר y = x נותנות לנו את הפתרון.</p>

             <p><strong>פתרון אלגברי:</strong></p>
             <div dir="ltr" style="text-align: left;">
             x² - 6x = 0<br>
             x(x - 6) = 0<br>
             x = 0 או x = 6
             </div>`;
            break;
        }

        if (intersectionPoints.length === 0) {
          explanationHTML +=
            '<p><strong>לא נמצאו נקודות חיתוך ממשיות.</strong> למשוואה אין פתרונות ממשיים.</p>';
        } else {
          // פורמט חדש לנקודות החיתוך
          explanationHTML +=
            '<p><strong>נקודות החיתוך שנמצאו (מסומנות באדום על הגרף): </strong></p><p dir="ltr" style="text-align: left;">';
          const pointsText = intersectionPoints
            .map((point) => {
              // הצגת מספרים בלי נקודה עשרונית אם הם שלמים
              const xFormatted =
                Math.abs(point.x - Math.round(point.x)) < 0.0001
                  ? Math.round(Math.abs(point.x))
                  : Math.abs(point.x).toFixed(2);
              const yFormatted =
                Math.abs(point.y - Math.round(point.y)) < 0.0001
                  ? Math.round(Math.abs(point.y))
                  : Math.abs(point.y).toFixed(2);

              // הוספת מינוס בצד שמאל אם צריך
              const xStr = point.x < 0 ? `-${xFormatted}` : xFormatted;
              const yStr = point.y < 0 ? `-${yFormatted}` : yFormatted;

              return `(${xStr}, ${yStr})`;
            })
            .join(', ');
          explanationHTML += pointsText + '</p>';
        }
        explanationBox.innerHTML = explanationHTML;
        // Ensure screenshot container is cleared when explanation updates
        document.getElementById('screenshotContainer').innerHTML = '';
      }

      function getLineEquationString(equationValue) {
        switch (equationValue) {
          case '1':
            return 'y = 3';
          case '2':
            return 'y = x + 4';
          case '3':
            return 'y = 6';
          case '4':
            return 'y = -2';
          case '5':
            return 'y = x';
          case '6':
            return 'y = x'; // (x^2 - 6x = 0 rewritten as x^2 - 5x = x)
          default:
            return '';
        }
      }

      // Initial chart draw and explanation
      const initialEquation = document.querySelector(
        'input[name="equation"]:checked'
      ).value;
      updateChart(initialEquation); // This now also calls updateExplanation

      // Set initial chart size
      resizeChart();

      // Update chart and explanation when radio button changes
      document.querySelectorAll('input[name="equation"]').forEach((radio) => {
        radio.addEventListener('change', (event) => {
          updateChart(event.target.value); // This updates chart and calls updateExplanation
          // Screenshot container is cleared inside updateExplanation now
        });
      });

      // Screenshot generation
      document
        .getElementById('generateScreenshotBtn')
        .addEventListener('click', async () => {
          const screenshotContainer = document.getElementById(
            'screenshotContainer'
          );
          screenshotContainer.innerHTML = ''; // Clear previous screenshot
          screenshotContainer.textContent = 'מכין תמונה של כל הפתרונות...'; // Loading message

          try {
            // Create a container for all six questions and their solutions
            const captureContainer = document.createElement('div');
            captureContainer.style.backgroundColor = 'white';
            captureContainer.style.padding = '15px';
            captureContainer.style.maxWidth = '700px';
            captureContainer.style.margin = '0 auto';
            captureContainer.style.direction = 'rtl';
            captureContainer.style.textAlign = 'right';
            captureContainer.style.fontFamily = 'Arial, sans-serif';

            // Add header
            const headerDiv = document.createElement('div');
            headerDiv.innerHTML = `
              <h1 style="font-size: 20px; text-align: center; margin-bottom: 20px;">פתרון גרפי למשוואות ריבועיות: y = x² - 5x</h1>
            `;
            captureContainer.appendChild(headerDiv);

            // Store current selection to restore later
            const currentSelectedEquation = document.querySelector(
              'input[name="equation"]:checked'
            ).value;

            // Define the order we want to process (1-6)
            const equationOrder = ['1', '2', '3', '4', '5', '6'];

            // Process each equation one by one
            for (let i = 0; i < equationOrder.length; i++) {
              const equationValue = equationOrder[i];
              const equationInput = document.querySelector(
                `input[value="${equationValue}"]`
              );
              const equationLabel = equationInput.parentNode.textContent.trim();

              // Select this equation (this will update the chart)
              equationInput.checked = true;

              // Trigger change event to update chart
              const changeEvent = new Event('change');
              equationInput.dispatchEvent(changeEvent);

              // Wait for chart to update
              await new Promise((resolve) => setTimeout(resolve, 200));

              // Create section for this equation
              const sectionDiv = document.createElement('div');
              sectionDiv.style.marginBottom = '30px';
              sectionDiv.style.paddingBottom = '30px';
              sectionDiv.style.borderBottom =
                i < equationOrder.length - 1 ? '2px dashed #aaa' : 'none';

              // Add question title
              const questionDiv = document.createElement('div');
              questionDiv.innerHTML = `
                <h2 style="font-size: 18px; margin-bottom: 10px; text-align: center;">${equationLabel}</h2>
              `;
              sectionDiv.appendChild(questionDiv);

              // Add the graph for this equation
              // Ensure chart background is white
              const canvas = document.getElementById('myChart');
              const tempCtx = canvas.getContext('2d');
              tempCtx.globalCompositeOperation = 'destination-over';
              tempCtx.fillStyle = '#ffffff';
              tempCtx.fillRect(0, 0, canvas.width, canvas.height);
              tempCtx.globalCompositeOperation = 'source-over';

              // Create graph image
              const graphImg = document.createElement('img');
              graphImg.src = myChart.toBase64Image('image/png');
              graphImg.alt = `גרף הפתרון למשוואה ${equationValue}`;
              graphImg.style.display = 'block';
              graphImg.style.width = '100%';
              graphImg.style.maxWidth = '600px';
              graphImg.style.margin = '15px auto';
              graphImg.style.border = '1px solid #ccc';
              sectionDiv.appendChild(graphImg);

              // Add the explanation for this equation
              const explanationDiv = document.createElement('div');
              explanationDiv.style.backgroundColor = '#f5f5f5';
              explanationDiv.style.padding = '15px';
              explanationDiv.style.border = '1px solid #ddd';
              explanationDiv.style.borderRadius = '5px';
              explanationDiv.style.marginTop = '15px';
              explanationDiv.style.fontSize = '14px';
              explanationDiv.innerHTML = explanationBox.innerHTML;
              sectionDiv.appendChild(explanationDiv);

              // Add this section to the main container
              captureContainer.appendChild(sectionDiv);
            }

            // Restore the original selection
            document.querySelector(
              `input[value="${currentSelectedEquation}"]`
            ).checked = true;
            document
              .querySelector(`input[value="${currentSelectedEquation}"]`)
              .dispatchEvent(new Event('change'));

            // Use html2canvas to create a screenshot of the entire content
            // Add html2canvas script if not already present
            if (!window.html2canvas) {
              const script = document.createElement('script');
              script.src =
                'https://html2canvas.hertzen.com/dist/html2canvas.min.js';
              script.onload = captureAndDownload;
              document.head.appendChild(script);
            } else {
              captureAndDownload();
            }

            function captureAndDownload() {
              // Add the capture container temporarily to the document
              document.body.appendChild(captureContainer);

              html2canvas(captureContainer, {
                backgroundColor: 'white',
                scale: 2, // Higher resolution
                logging: false,
                useCORS: true,
              }).then((canvas) => {
                // Remove the temporary container
                document.body.removeChild(captureContainer);

                // Clear loading message
                screenshotContainer.innerHTML = '';

                // Create data URL and display image
                const dataUrl = canvas.toDataURL('image/png');

                // Open image in new tab
                const newTab = window.open();
                newTab.document.write(`
                  <html>
                    <head>
                      <title>פתרון גרפי מלא - כל המשוואות</title>
                      <style>
                        body {
                          margin: 0;
                          padding: 0;
                          display: flex;
                          flex-direction: column;
                          align-items: center;
                          background-color: #f5f5f5;
                          font-family: Arial, sans-serif;
                        }
                        img {
                          max-width: 100%;
                          margin: 10px 0;
                        }
                        .container {
                          text-align: center;
                          padding: 20px;
                        }
                        a.download-btn {
                          display: inline-block;
                          margin-top: 20px;
                          padding: 10px 15px;
                          background-color: #007bff;
                          color: white;
                          text-decoration: none;
                          border-radius: 5px;
                          font-weight: bold;
                        }
                      </style>
                    </head>
                    <body>
                      <div class="container">
                        <h1 style="text-align: center; direction: rtl;">פתרון גרפי מלא - כל המשוואות</h1>
                        <img src="${dataUrl}" alt="פתרון גרפי מלא" />
                        <br>
                        <a class="download-btn" href="${dataUrl}" download="פתרון_גרפי_מלא_כל_המשוואות.png">הורד תמונה</a>
                      </div>
                    </body>
                  </html>
                `);
                newTab.document.close();

                // Update the message in the original page
                screenshotContainer.innerHTML = '<p>התמונה נפתחה בחלון חדש</p>';
              });
            }
          } catch (error) {
            console.error('Error generating screenshot:', error);
            screenshotContainer.textContent = 'שגיאה ביצירת התמונה.';
          }
        });

      // Add custom plugin to ensure axes cross at (0,0) and draw arrows
      Chart.register({
        id: 'cartesianAxes',
        beforeDraw: function (chart, args, options) {
          if (!options.enabled) return;

          const ctx = chart.ctx;
          const scales = chart.scales;
          const xScale = scales.x;
          const yScale = scales.y;

          // Only proceed if we have valid scales
          if (!xScale || !yScale) return;

          // Draw X axis through y=0 position
          const zeroY = yScale.getPixelForValue(0);
          if (zeroY >= yScale.top && zeroY <= yScale.bottom) {
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(xScale.left, zeroY);
            ctx.lineTo(xScale.right, zeroY);
            ctx.stroke();

            // Draw arrow at the end of X axis
            const arrowSize = 10;
            ctx.beginPath();
            ctx.moveTo(xScale.right, zeroY);
            ctx.lineTo(xScale.right - arrowSize, zeroY - arrowSize / 2);
            ctx.lineTo(xScale.right - arrowSize, zeroY + arrowSize / 2);
            ctx.closePath();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fill();
            ctx.restore();
          }

          // Draw Y axis through x=0 position
          const zeroX = xScale.getPixelForValue(0);
          if (zeroX >= xScale.left && zeroX <= xScale.right) {
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(zeroX, yScale.bottom);
            ctx.lineTo(zeroX, yScale.top);
            ctx.stroke();

            // Draw arrow at the end of Y axis
            const arrowSize = 10;
            ctx.beginPath();
            ctx.moveTo(zeroX, yScale.top);
            ctx.lineTo(zeroX - arrowSize / 2, yScale.top + arrowSize);
            ctx.lineTo(zeroX + arrowSize / 2, yScale.top + arrowSize);
            ctx.closePath();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fill();
            ctx.restore();
          }
        },
      });
    </script>
  </body>
</html>
